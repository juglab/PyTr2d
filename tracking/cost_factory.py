import yaml
import io
from scipy.spatial import distance

class cost_factory:
    '''
    A cost factory serves all cost functions to set up a PyTr2d tracking problem.
    The individual cost functions are parametrized individually, with parameters being
    loaded from file or set programmatically.
    '''

    parameters = {
        'segmentation': [
            1,          # lambda (global scaling of this cost)
            1,          # w_size: factor for difference in size
            300,        # bias
        ],
        'appearance': [
            1,          # lambda (global scaling of this cost)
            10,          # min cost
            13,          # slope
            400,         # max value
        ],
        'disappearance': [
            1,          # lambda (global scaling of this cost)
            50,          # min cost
            15,          # slope
            500,         # max value
        ],
        'movement': [
            1,          # lambda (global scaling of this cost)
            2,          # w_dist: factor for distance in pixels
            0.1,        # w_size: factor for difference in size
        ],
        'division': [
            0.5,        # lambda (global scaling of this cost)
            1,          # w_dist: factor for distance in pixels
            0.1,          # w_size: factor for difference in size
        ]
    }

    def __init__(self, parameters_yaml_file=None):
        '''
        Constructor: if filename to parameters_yaml_file is not given, default values will be used
        '''
        if parameters_yaml_file is None:
            return
        self.load_parameters(parameters_yaml_file)

    def save_parameters(self, filename):
        '''
        Saves self.parameters in a YAML file for later reuse.
        :param filename: string pointing to the YAML file the parameters should be stored in.
        :return: nothing
        '''
        with io.open(filename, 'w', encoding='utf8') as outfile:
            yaml.dump(self.parameters, outfile, default_flow_style=False, allow_unicode=True)

    def load_parameters(self, filename):
        '''
        Loads a YAML file containing all cost funciton parameters (structure can be generated by saving a YAML
        using self.save_parameters).
        :param filename: string pointing to the YAML file the parameters should be stored in.
        :return: nothing
        '''
        with open(filename, 'r') as stream:
            self.parameters = yaml.safe_load(stream)


    def get_segmentation_cost(self,size):
        '''
        Explain what the f it does... and why it is negative... ;)
        :param size: size of the cell
        :param you: is
        :param need: this
        :return: returns the costs for an appearance event
        '''
        return -self.parameters['segmentation'][0]*self.parameters['segmentation'][0]*size

    def get_appearance_cost(self,centroid,dimention):
        '''
        Explain what the f it does...
        :param stuff: what
        :param you: is
        :param need: this
        :return: returns the costs for an appearance event
        '''
        x = centroid[0]
        y = centroid[1]
        outer_margin = 25 #Field of interest of the dataset (E)
        inner_margin = 55
        lam = self.parameters['appearance'][0]
        min = self.parameters['appearance'][1]
        slope = self.parameters['appearance'][2]
        max = self.parameters['appearance'][3]

        if x <= outer_margin or x >= dimention[0]-outer_margin:
            return lam * min
        elif y <= outer_margin or y >= dimention[1]-outer_margin:
            return lam * min
        elif x <= inner_margin:
            return lam * ( slope * (inner_margin - x) + min)
        elif x >= dimention[0] - inner_margin:
            return lam * (slope * (x - dimention[0] + inner_margin) + min)
        elif y <= inner_margin:
            return lam * (slope * (inner_margin - y) + min)
        elif y >= dimention[1] - inner_margin:
            return lam * (slope * (y - dimention[1] + inner_margin) + min)
        else:
            return lam * max

    def get_disappearance_cost(self,centroid,dimention):
        '''
        Explain what the f it does...
        :param stuff: what
        :param you: is
        :param need: this
        :return: returns the costs for an appearance event
        '''
        x = centroid[0]
        y = centroid[1]
        outer_margin = 25
        inner_margin = 55
        lam = self.parameters['disappearance'][0]
        min = self.parameters['disappearance'][1]
        slope = self.parameters['disappearance'][2]
        max = self.parameters['disappearance'][3]

        if x <= outer_margin or x >= dimention[0] - outer_margin:
            return lam * min
        elif y <= outer_margin or y >= dimention[1] - outer_margin:
            return lam * min
        elif x <= inner_margin:
            return lam * (slope * (inner_margin - x) + min)
        elif x >= dimention[0] - inner_margin:
            return lam * (slope * (x - dimention[0] + inner_margin) + min)
        elif y <= inner_margin:
            return lam * (slope * (inner_margin - y) + min)
        elif y >= dimention[1] - inner_margin:
            return lam * (slope * (y - dimention[1] + inner_margin) + min)
        else:
            return lam * max

    def get_movement_cost(self,size1,centroid1,size2,centroid2):
        '''
        Explain what the f it does...
        :param stuff: what
        :param you: is
        :param need: this
        :return: returns the costs for an appearance event
        '''
        return self.parameters['movement'][0] * (
                    self.parameters['movement'][1] * distance.euclidean(centroid1, centroid2) +
                    self.parameters['movement'][2] * abs(size1 - size2))

    def get_division_cost(self,size1,centroid1,size2,centroid2,size3,centroid3):
        '''
        Explain what the f it does...
        :param stuff: what
        :param you: is
        :param need: this
        :return: returns the costs for an appearance event
        '''
        return self.parameters['division'][0] * (abs(self.parameters['division'][1] * ((distance.euclidean(centroid1,
                                                                                                           centroid2) + distance.euclidean(
            centroid1, centroid3)) / 2 - distance.euclidean(centroid2, centroid3))) + abs(
            self.parameters['division'][2] * size1 - (size2 + size3)))